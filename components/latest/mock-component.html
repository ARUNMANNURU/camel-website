<!doctype html> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width,initial-scale=1"> <title>Mock Component - Apache Camel</title> <link rel="canonical" href="https://camel.apache.org/components/latest/mock-component.html"> <meta name="generator" content="Antora 2.1.0"> <link rel="stylesheet" href="../../_/css/site-1c739ae396.css"> <meta name="application-name" content="Apache Camel"> <link rel="manifest" href="../../site.webmanifest"> <link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../apple-touch-icon-57x57.png"> <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../apple-touch-icon-114x114.png"> <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../apple-touch-icon-72x72.png"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../apple-touch-icon-144x144.png"> <link rel="apple-touch-icon-precomposed" sizes="60x60" href="../../apple-touch-icon-60x60.png"> <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../../apple-touch-icon-120x120.png"> <link rel="apple-touch-icon-precomposed" sizes="76x76" href="../../apple-touch-icon-76x76.png"> <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../apple-touch-icon-152x152.png"> <link rel="icon" type="image/png" href="../../favicon-196x196.png" sizes="196x196"> <link rel="icon" type="image/png" href="../../favicon-96x96.png" sizes="96x96"> <link rel="icon" type="image/png" href="../../favicon-32x32.png" sizes="32x32"> <link rel="icon" type="image/png" href="../../favicon-16x16.png" sizes="16x16"> <link rel="icon" type="image/png" href="../../favicon-128.png" sizes="128x128"> </head> <body class="article"> <header class="header"> <nav class="navbar"> <div class="navbar-brand"> <a class="nav-logo" href="../.."><span>Apache Camel</span></a> <div id="topbar-nav" class="navbar-menu"> <div class="navbar-end"> <a class="navbar-item" href="../../blog/">Blog</a> <div class="navbar-item has-dropdown is-hoverable"> <a class="navbar-link" href="#">Projects</a> <div class="navbar-dropdown"> <a class="navbar-item" href="../../projects/camel-k/">Camel K</a> <a class="navbar-item" href="../../projects/camel-quarkus/">Camel Quarkus</a> </div> </div> <div class="navbar-item has-dropdown is-hoverable"> <a class="navbar-link" href="#">Documentation</a> <div class="navbar-dropdown"> <a class="navbar-item" href="../../docs/getting-started/">Getting started</a> <a class="navbar-item" href="../../manual/latest/">User manual</a> <a class="navbar-item" href="../../components/latest/">Component reference</a> <a class="navbar-item" href="../../camel-k/latest/">Camel K</a> <a class="navbar-item" href="../../camel-quarkus/latest/">Camel Quarkus</a> <a class="navbar-item" href="../../manual/latest/enterprise-integration-patterns.html">Enterprise Integration Patterns</a> <a class="navbar-item" href="../../manual/latest/camel-3-migration-guide.html">Camel 3 Migration Guide</a> </div> </div> <div class="navbar-item has-dropdown is-hoverable"> <a class="navbar-link" href="#">Community</a> <div class="navbar-dropdown"> <a class="navbar-item" href="../../community/support/">Support</a> <a class="navbar-item" href="https://github.com/apache/camel/blob/master/CONTRIBUTING.md">Contributing</a> <a class="navbar-item" href="../../community/user-stories/">User stories</a> <a class="navbar-item" href="../../community/articles/">Articles</a> <a class="navbar-item" href="../../community/books/">Books</a> <a class="navbar-item" href="../../community/team/">Team</a> </div> </div> <a class="navbar-item" href="../../download/">Download</a> <div class="navbar-item has-dropdown is-hoverable"> <a class="navbar-link" href="#">About</a> <div class="navbar-dropdown"> <a class="navbar-item" href="https://www.apache.org/events/current-event.html">Apache events</a> <a class="navbar-item" href="https://www.apache.org/licenses/">License</a> <a class="navbar-item" href="../../security/">Security</a> <a class="navbar-item" href="https://www.apache.org/foundation/sponsorship.html">Sponsorship</a> <a class="navbar-item" href="https://www.apache.org/foundation/thanks.html">Thanks</a> </div> </div> </div> </div> <div class="navbar-tools"> <a href="https://github.com/apache/camel/" title="Collaborate on GitHub"><svg class="brand-icon"><use xlink:href="../../_/img/brand-logos.svg#github"/></svg></a> <a href="https://gitter.im/apache/apache-camel" title="Chat on Gitter"><svg class="brand-icon"><use xlink:href="../../_/img/brand-logos.svg#gitter"/></svg></a> <a href="https://twitter.com/ApacheCamel" title="Follow Apache Camel on Twitter"><svg class="brand-icon"><use xlink:href="../../_/img/brand-logos.svg#twitter"/></svg></a> </div> <button class="navbar-burger" data-target="topbar-nav" type="button"> <span></span> <span></span> <span></span> </button> </div> </nav> </header> <div class="body"> <div class="nav-container" data-component="components" data-version="latest"> <aside class="nav"> <div class="panels"> <div class="nav-panel-explore is-active" data-panel="explore"> <div class="context"> <span class="title">Component reference</span> <span class="version">latest</span> </div> <ul class="components"> <li class="component"> <span class="title">Apache Camel extensions for Quarkus</span> <ul class="versions"> <li class="version is-latest"> <a href="../../camel-quarkus/latest/index.html">latest</a> </li> </ul> </li> <li class="component"> <span class="title">Apache Camel K</span> <ul class="versions"> <li class="version is-latest"> <a href="../../camel-k/latest/index.html">latest</a> </li> </ul> </li> <li class="component is-current"> <span class="title">Component reference</span> <ul class="versions"> <li class="version is-current is-latest"> <a href="index.html">latest</a> </li> <li class="version"> <a href="../2.x/index.html">2.x</a> </li> </ul> </li> <li class="component"> <span class="title">User manual</span> <ul class="versions"> <li class="version is-latest"> <a href="../../manual/latest/index.html">latest</a> </li> </ul> </li> </ul> </div> </div> </aside> </div> <main role="main"> <div class="toolbar" role="navigation"> <button class="nav-toggle"></button> <a href="../../manual/latest/index.html" class="home-link"></a> <nav class="breadcrumbs" aria-label="breadcrumbs"> <ul> <li><a href="index.html">Component reference</a></li> <li><a href="mock-component.html">Mock Component</a></li> </ul> </nav> <div class="page-versions"> <button class="version-menu-toggle" title="Show other versions of page" type="button">latest</button> <div class="version-menu"> <a class="version is-current" href="mock-component.html">latest</a> <a class="version is-missing" href="../2.x/index.html">2.x</a> </div> </div> <div class="edit-this-page"><a href="https://github.com/apache/camel/edit/master/components/camel-mock/src/main/docs/mock-component.adoc">Edit this Page</a></div> </div> <article class="doc"> <h1 class="page">Mock Component</h1> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p><strong>Available as of Camel version 1.0</strong></p> </div> <div class="paragraph"> <p>Testing of distributed and asynchronous processing is notoriously difficult. The <a href="#">Mock</a>, <a href="#">Test</a> and <a href="dataset-component.html" class="page">DataSet</a> endpoints work great with the Camel Testing Framework to simplify your unit and integration testing using <a href="../../manual/latest/enterprise-integration-patterns.html" class="page">Enterprise Integration Patterns</a> and Camel&#8217;s large range of Components together with the powerful Bean Integration.</p> </div> <div class="paragraph"> <p>The Mock component provides a powerful declarative testing mechanism, which is similar to <a href="http://www.jmock.org">jMock</a> in that it allows declarative expectations to be created on any Mock endpoint before a test begins. Then the test is run, which typically fires messages to one or more endpoints, and finally the expectations can be asserted in a test case to ensure the system worked as expected.</p> </div> <div class="paragraph"> <p>This allows you to test various things like:</p> </div> <div class="ulist"> <ul> <li> <p>The correct number of messages are received on each endpoint,</p> </li> <li> <p>The correct payloads are received, in the right order,</p> </li> <li> <p>Messages arrive on an endpoint in order, using some Expression to create an order testing function,</p> </li> <li> <p>Messages arrive match some kind of Predicate such as that specific headers have certain values, or that parts of the messages match some predicate, such as by evaluating an <a href="xpath-language.html" class="page">XPath</a> or <a href="xpath-language.html" class="page">XQuery</a> Expression.</p> </li> </ul> </div> <div class="admonitionblock note"> <div class="table-wrapper"><table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> There is also the <a href="test.html" class="page">Test endpoint</a> which is a Mock endpoint, but which uses a second endpoint to provide the list of expected message bodies and automatically sets up the Mock endpoint assertions. In other words, it&#8217;s a Mock endpoint that automatically sets up its assertions from some sample messages in a File or <a href="jpa-component.html" class="page">database</a>, for example. </td> </tr> </table></div> </div> <div class="admonitionblock caution"> <div class="table-wrapper"><table> <tr> <td class="icon"> <i class="fa icon-caution" title="Caution"></i> </td> <td class="content"> <strong>Mock endpoints keep received Exchanges in memory indefinitely.</strong><br> <br> Remember that Mock is designed for testing. When you add Mock endpoints to a route, each Exchange sent to the endpoint will be stored (to allow for later validation) in memory until explicitly reset or the JVM is restarted. If you are sending high volume and/or large messages, this may cause excessive memory use. If your goal is to test deployable routes inline, consider using NotifyBuilder or AdviceWith in your tests instead of adding Mock endpoints to routes directly.<br> <br> There are two new options <code>retainFirst</code>, and <code>retainLast</code> that can be used to limit the number of messages the Mock endpoints keep in memory. </td> </tr> </table></div> </div> </div> </div> <div class="sect1"> <h2 id="_uri_format"><a class="anchor" href="#_uri_format"></a>URI format</h2> <div class="sectionbody"> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code>mock:someName[?options]</code></pre> </div> </div> <div class="paragraph"> <p>Where <code>someName</code> can be any string that uniquely identifies the endpoint.</p> </div> <div class="paragraph"> <p>You can append query options to the URI in the following format, <code>?option=value&amp;option=value&amp;&#8230;&#8203;</code></p> </div> </div> </div> <div class="sect1"> <h2 id="_options"><a class="anchor" href="#_options"></a>Options</h2> <div class="sectionbody"> <div class="paragraph"> <p>The Mock component supports 1 options, which are listed below.</p> </div> <div class="table-wrapper"><table class="tableblock frame-all grid-all stretch"> <colgroup> <col> <col> <col> <col> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Name</th> <th class="tableblock halign-left valign-top">Description</th> <th class="tableblock halign-center valign-top">Default</th> <th class="tableblock halign-left valign-top">Type</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>basicPropertyBinding</strong> (advanced)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td> </tr> </tbody> </table></div> <div class="paragraph"> <p>The Mock endpoint is configured using URI syntax:</p> </div> <div class="listingblock"> <div class="content"> <pre>mock:name</pre> </div> </div> <div class="paragraph"> <p>with the following path and query parameters:</p> </div> <div class="sect2"> <h3 id="_path_parameters_1_parameters"><a class="anchor" href="#_path_parameters_1_parameters"></a>Path Parameters (1 parameters):</h3> <div class="table-wrapper"><table class="tableblock frame-all grid-all stretch"> <colgroup> <col> <col> <col> <col> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Name</th> <th class="tableblock halign-left valign-top">Description</th> <th class="tableblock halign-center valign-top">Default</th> <th class="tableblock halign-left valign-top">Type</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>name</strong></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Required</strong> Name of mock endpoint</p></td> <td class="tableblock halign-center valign-top"></td> <td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td> </tr> </tbody> </table></div> </div> <div class="sect2"> <h3 id="_query_parameters_13_parameters"><a class="anchor" href="#_query_parameters_13_parameters"></a>Query Parameters (13 parameters):</h3> <div class="table-wrapper"><table class="tableblock frame-all grid-all stretch"> <colgroup> <col> <col> <col> <col> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Name</th> <th class="tableblock halign-left valign-top">Description</th> <th class="tableblock halign-center valign-top">Default</th> <th class="tableblock halign-left valign-top">Type</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>assertPeriod</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Sets a grace period after which the mock endpoint will re-assert to ensure the preliminary assertion is still valid. This is used for example to assert that exactly a number of messages arrives. For example if expectedMessageCount(int) was set to 5, then the assertion is satisfied when 5 or more message arrives. To ensure that exactly 5 messages arrives, then you would need to wait a little period to ensure no further message arrives. This is what you can use this method for. By default this period is disabled.</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>expectedCount</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the expected number of message exchanges that should be received by this endpoint. Beware: If you want to expect that 0 messages, then take extra care, as 0 matches when the tests starts, so you need to set a assert period time to let the test run for a while to make sure there are still no messages arrived; for that use setAssertPeriod(long). An alternative is to use NotifyBuilder, and use the notifier to know when Camel is done routing some messages, before you call the assertIsSatisfied() method on the mocks. This allows you to not use a fixed assert period, to speedup testing times. If you want to assert that exactly n&#8217;th message arrives to this mock endpoint, then see also the setAssertPeriod(long) method for further details.</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">-1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>failFast</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Sets whether assertIsSatisfied() should fail fast at the first detected failed expectation while it may otherwise wait for all expected messages to arrive before performing expectations verifications. Is by default true. Set to false to use behavior as in Camel 2.x.</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>lazyStartProducer</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel&#8217;s routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>reportGroup</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">A number that is used to turn on throughput logging based on groups of the size.</p></td> <td class="tableblock halign-center valign-top"></td> <td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>resultMinimumWaitTime</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Sets the minimum expected amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>resultWaitTime</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Sets the maximum amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>retainFirst</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Specifies to only retain the first n&#8217;th number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the first 10 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the first 10 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object&#8230;&#8203;) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">-1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>retainLast</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Specifies to only retain the last n&#8217;th number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the last 20 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the last 20 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object&#8230;&#8203;) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">-1</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>sleepForEmptyTest</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Allows a sleep to be specified to wait to check that this endpoint really is empty when expectedMessageCount(int) is called with zero</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>copyOnExchange</strong> (producer)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Sets whether to make a deep copy of the incoming Exchange when received at this mock endpoint. Is by default true.</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">true</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>basicPropertyBinding</strong> (advanced)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Whether the endpoint should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>synchronous</strong> (advanced)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Sets whether synchronous processing should be strictly used, or Camel is allowed to use asynchronous processing (if supported).</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td> </tr> </tbody> </table></div> </div> </div> </div> <div class="sect1"> <h2 id="_spring_boot_auto_configuration"><a class="anchor" href="#_spring_boot_auto_configuration"></a>Spring Boot Auto-Configuration</h2> <div class="sectionbody"> <div class="paragraph"> <p>When using Spring Boot make sure to use the following Maven dependency to have support for auto configuration:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
  &lt;artifactId&gt;camel-mock-starter&lt;/artifactId&gt;
  &lt;version&gt;x.x.x&lt;/version&gt;
  &lt;!-- use the same version as your Camel core version --&gt;
&lt;/dependency&gt;</code></pre> </div> </div> <div class="paragraph"> <p>The component supports 2 options, which are listed below.</p> </div> <div class="table-wrapper"><table class="tableblock frame-all grid-all stretch"> <colgroup> <col> <col> <col> <col> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Name</th> <th class="tableblock halign-left valign-top">Description</th> <th class="tableblock halign-center valign-top">Default</th> <th class="tableblock halign-left valign-top">Type</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>camel.component.mock.basic-property-binding</strong></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Whether the component should use basic property binding (Camel 2.x) or the newer property binding with additional capabilities</p></td> <td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><strong>camel.component.mock.enabled</strong></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Whether to enable auto configuration of the mock component. This is enabled by default.</p></td> <td class="tableblock halign-center valign-top"></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td> </tr> </tbody> </table></div> </div> </div> <div class="sect1"> <h2 id="_simple_example"><a class="anchor" href="#_simple_example"></a>Simple Example</h2> <div class="sectionbody"> <div class="paragraph"> <p>Here&#8217;s a simple example of Mock endpoint in use. First, the endpoint is resolved on the context. Then we set an expectation, and then, after the test has run, we assert that our expectations have been met:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MockEndpoint resultEndpoint = context.resolveEndpoint("mock:foo", MockEndpoint.class);

// set expectations
resultEndpoint.expectedMessageCount(2);

// send some messages

// now lets assert that the mock:foo endpoint received 2 messages
resultEndpoint.assertIsSatisfied();</code></pre> </div> </div> <div class="paragraph"> <p>You typically always call the <a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#assertIsSatisfied()"><code>assertIsSatisfied()</code></a> method to test that the expectations were met after running a test.</p> </div> <div class="paragraph"> <p>Camel will by default wait 10 seconds when the <code>assertIsSatisfied()</code> is invoked. This can be configured by setting the <code>setResultWaitTime(millis)</code> method.</p> </div> </div> </div> <div class="sect1"> <h2 id="_using_assertperiod"><a class="anchor" href="#_using_assertperiod"></a>Using assertPeriod</h2> <div class="sectionbody"> <div class="paragraph"> <p>When the assertion is satisfied then Camel will stop waiting and continue from the <code>assertIsSatisfied</code> method. That means if a new message arrives on the mock endpoint, just a bit later, that arrival will not affect the outcome of the assertion. Suppose you do want to test that no new messages arrives after a period thereafter, then you can do that by setting the <code>setAssertPeriod</code> method, for example:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MockEndpoint resultEndpoint = context.resolveEndpoint("mock:foo", MockEndpoint.class);
resultEndpoint.setAssertPeriod(5000);
resultEndpoint.expectedMessageCount(2);

// send some messages

// now lets assert that the mock:foo endpoint received 2 messages
resultEndpoint.assertIsSatisfied();</code></pre> </div> </div> </div> </div> <div class="sect1"> <h2 id="_setting_expectations"><a class="anchor" href="#_setting_expectations"></a>Setting expectations</h2> <div class="sectionbody"> <div class="paragraph"> <p>You can see from the Javadoc of <a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html">MockEndpoint</a> the various helper methods you can use to set expectations. The main methods are as follows:</p> </div> <div class="table-wrapper"><table class="tableblock frame-all grid-all stretch"> <colgroup> <col> <col> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Method</th> <th class="tableblock halign-left valign-top">Description</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectedMessageCount(int)">expectedMessageCount(int)</a></code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">To define the expected message count on the endpoint.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectedMinimumMessageCount(int)">expectedMinimumMessageCount(int)</a></code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">To define the minimum number of expected messages on the endpoint.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectedBodiesReceived(java.lang.Object&#8230;&#8203;)">expectedBodiesReceived(&#8230;&#8203;)</a></code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">To define the expected bodies that should be received (in order).</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectedHeaderReceived(java.lang.String,%20java.lang.String)">expectedHeaderReceived(&#8230;&#8203;)</a></code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">To define the expected header that should be received</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectsAscending(org.apache.camel.Expression)">expectsAscending(Expression)</a></code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">To add an expectation that messages are received in order, using the given Expression to compare messages.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectsDescending(org.apache.camel.Expression)">expectsDescending(Expression)</a></code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">To add an expectation that messages are received in order, using the given Expression to compare messages.</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#expectsNoDuplicates(org.apache.camel.Expression)">expectsNoDuplicates(Expression)</a></code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">To add an expectation that no duplicate messages are received; using an Expression to calculate a unique identifier for each message. This could be something like the <code>JMSMessageID</code> if using JMS, or some unique reference number within the message.</p></td> </tr> </tbody> </table></div> <div class="paragraph"> <p>Here&#8217;s another example:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">resultEndpoint.expectedBodiesReceived("firstMessageBody", "secondMessageBody", "thirdMessageBody");</code></pre> </div> </div> </div> </div> <div class="sect1"> <h2 id="_adding_expectations_to_specific_messages"><a class="anchor" href="#_adding_expectations_to_specific_messages"></a>Adding expectations to specific messages</h2> <div class="sectionbody"> <div class="paragraph"> <p>In addition, you can use the <a href="http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/mock/MockEndpoint.html#message(int)"><code>message(int messageIndex)</code></a> method to add assertions about a specific message that is received.</p> </div> <div class="paragraph"> <p>For example, to add expectations of the headers or body of the first message (using zero-based indexing like <code>java.util.List</code>), you can use the following code:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">resultEndpoint.message(0).header("foo").isEqualTo("bar");</code></pre> </div> </div> <div class="paragraph"> <p>There are some examples of the Mock endpoint in use in the <a href="https://github.com/apache/camel/tree/master/camel-core/src/test/java/org/apache/camel/processor/"><code>camel-core</code> processor tests</a>.</p> </div> </div> </div> <div class="sect1"> <h2 id="_mocking_existing_endpoints"><a class="anchor" href="#_mocking_existing_endpoints"></a>Mocking existing endpoints</h2> <div class="sectionbody"> <div class="paragraph"> <p>Camel now allows you to automatically mock existing endpoints in your Camel routes.</p> </div> <div class="admonitionblock note"> <div class="table-wrapper"><table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> <strong>How it works</strong> The endpoints are still in action. What happens differently is that a <a href="#">Mock</a> endpoint is injected and receives the message first and then delegates the message to the target endpoint. You can view this as a kind of intercept and delegate or endpoint listener. </td> </tr> </table></div> </div> <div class="paragraph"> <p>Suppose you have the given route below:</p> </div> <div class="listingblock"> <div class="title"><strong>Route</strong></div> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct:start").to("direct:foo").to("log:foo").to("mock:result");

                from("direct:foo").transform(constant("Bye World"));
            }
        };
    }</code></pre> </div> </div> <div class="paragraph"> <p>You can then use the <code>adviceWith</code> feature in Camel to mock all the endpoints in a given route from your unit test, as shown below:</p> </div> <div class="listingblock"> <div class="title"><strong><code>adviceWith</code> mocking all endpoints</strong></div> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Test
    public void testAdvisedMockEndpoints() throws Exception {
        // advice the first route using the inlined AdviceWith route builder
        // which has extended capabilities than the regular route builder
        RouteReifier.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() {
            @Override
            public void configure() throws Exception {
                // mock all endpoints
                mockEndpoints();
            }
        });

        getMockEndpoint("mock:direct:start").expectedBodiesReceived("Hello World");
        getMockEndpoint("mock:direct:foo").expectedBodiesReceived("Hello World");
        getMockEndpoint("mock:log:foo").expectedBodiesReceived("Bye World");
        getMockEndpoint("mock:result").expectedBodiesReceived("Bye World");

        template.sendBody("direct:start", "Hello World");

        assertMockEndpointsSatisfied();

        // additional test to ensure correct endpoints in registry
        assertNotNull(context.hasEndpoint("direct:start"));
        assertNotNull(context.hasEndpoint("direct:foo"));
        assertNotNull(context.hasEndpoint("log:foo"));
        assertNotNull(context.hasEndpoint("mock:result"));
        // all the endpoints was mocked
        assertNotNull(context.hasEndpoint("mock:direct:start"));
        assertNotNull(context.hasEndpoint("mock:direct:foo"));
        assertNotNull(context.hasEndpoint("mock:log:foo"));
    }</code></pre> </div> </div> <div class="paragraph"> <p>Notice that the mock endpoints is given the URI <code>mock:&lt;endpoint&gt;</code>, for example <code>mock:direct:foo</code>. Camel logs at <code>INFO</code> level the endpoints being mocked:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code>INFO  Adviced endpoint [direct://foo] with mock endpoint [mock:direct:foo]</code></pre> </div> </div> <div class="admonitionblock note"> <div class="table-wrapper"><table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> <strong>Mocked endpoints are without parameters</strong><br> Endpoints which are mocked will have their parameters stripped off. For example the endpoint <code>log:foo?showAll=true</code> will be mocked to the following endpoint <code>mock:log:foo</code>. Notice the parameters have been removed. </td> </tr> </table></div> </div> <div class="paragraph"> <p>Its also possible to only mock certain endpoints using a pattern. For example to mock all <code>log</code> endpoints you do as shown:</p> </div> <div class="listingblock"> <div class="title"><strong><code>adviceWith</code> mocking only log endpoints using a pattern</strong></div> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Test
    public void testAdvisedMockEndpointsWithPattern() throws Exception {
        // advice the first route using the inlined AdviceWith route builder
        // which has extended capabilities than the regular route builder
        RouteReifier.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() {
            @Override
            public void configure() throws Exception {
                // mock only log endpoints
                mockEndpoints("log*");
            }
        });

        // now we can refer to log:foo as a mock and set our expectations
        getMockEndpoint("mock:log:foo").expectedBodiesReceived("Bye World");

        getMockEndpoint("mock:result").expectedBodiesReceived("Bye World");

        template.sendBody("direct:start", "Hello World");

        assertMockEndpointsSatisfied();

        // additional test to ensure correct endpoints in registry
        assertNotNull(context.hasEndpoint("direct:start"));
        assertNotNull(context.hasEndpoint("direct:foo"));
        assertNotNull(context.hasEndpoint("log:foo"));
        assertNotNull(context.hasEndpoint("mock:result"));
        // only the log:foo endpoint was mocked
        assertNotNull(context.hasEndpoint("mock:log:foo"));
        assertNull(context.hasEndpoint("mock:direct:start"));
        assertNull(context.hasEndpoint("mock:direct:foo"));
    }</code></pre> </div> </div> <div class="paragraph"> <p>The pattern supported can be a wildcard or a regular expression. See more details about this at Intercept as its the same matching function used by Camel.</p> </div> <div class="admonitionblock note"> <div class="table-wrapper"><table> <tr> <td class="icon"> <i class="fa icon-note" title="Note"></i> </td> <td class="content"> Mind that mocking endpoints causes the messages to be copied when they arrive on the mock.<br> That means Camel will use more memory. This may not be suitable when you send in a lot of messages. </td> </tr> </table></div> </div> </div> </div> <div class="sect1"> <h2 id="_mocking_existing_endpoints_using_the_camel_test_component"><a class="anchor" href="#_mocking_existing_endpoints_using_the_camel_test_component"></a>Mocking existing endpoints using the <code>camel-test</code> component</h2> <div class="sectionbody"> <div class="paragraph"> <p>Instead of using the <code>adviceWith</code> to instruct Camel to mock endpoints, you can easily enable this behavior when using the <code>camel-test</code> Test Kit.</p> </div> <div class="paragraph"> <p>The same route can be tested as follows. Notice that we return <code>"*"</code> from the <code>isMockEndpoints</code> method, which tells Camel to mock all endpoints.</p> </div> <div class="paragraph"> <p>If you only want to mock all <code>log</code> endpoints you can return <code>"log*"</code> instead.</p> </div> <div class="listingblock"> <div class="title"><strong><code>isMockEndpoints</code> using camel-test kit</strong></div> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IsMockEndpointsJUnit4Test extends CamelTestSupport {

    @Override
    public String isMockEndpoints() {
        // override this method and return the pattern for which endpoints to mock.
        // use * to indicate all
        return "*";
    }

    @Test
    public void testMockAllEndpoints() throws Exception {
        // notice we have automatic mocked all endpoints and the name of the endpoints is "mock:uri"
        getMockEndpoint("mock:direct:start").expectedBodiesReceived("Hello World");
        getMockEndpoint("mock:direct:foo").expectedBodiesReceived("Hello World");
        getMockEndpoint("mock:log:foo").expectedBodiesReceived("Bye World");
        getMockEndpoint("mock:result").expectedBodiesReceived("Bye World");

        template.sendBody("direct:start", "Hello World");

        assertMockEndpointsSatisfied();

        // additional test to ensure correct endpoints in registry
        assertNotNull(context.hasEndpoint("direct:start"));
        assertNotNull(context.hasEndpoint("direct:foo"));
        assertNotNull(context.hasEndpoint("log:foo"));
        assertNotNull(context.hasEndpoint("mock:result"));
        // all the endpoints was mocked
        assertNotNull(context.hasEndpoint("mock:direct:start"));
        assertNotNull(context.hasEndpoint("mock:direct:foo"));
        assertNotNull(context.hasEndpoint("mock:log:foo"));
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct:start").to("direct:foo").to("log:foo").to("mock:result");

                from("direct:foo").transform(constant("Bye World"));
            }
        };
    }
}</code></pre> </div> </div> </div> </div> <div class="sect1"> <h2 id="_mocking_existing_endpoints_with_xml_dsl"><a class="anchor" href="#_mocking_existing_endpoints_with_xml_dsl"></a>Mocking existing endpoints with XML DSL</h2> <div class="sectionbody"> <div class="paragraph"> <p>If you do not use the <code>camel-test</code> component for unit testing (as shown above) you can use a different approach when using XML files for routes.<br> The solution is to create a new XML file used by the unit test and then include the intended XML file which has the route you want to test.</p> </div> <div class="paragraph"> <p>Suppose we have the route in the <code>camel-route.xml</code> file:</p> </div> <div class="listingblock"> <div class="title"><strong>camel-route.xml</strong></div> <div class="content"> <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;!-- this camel route is in the camel-route.xml file --&gt;
    &lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;

        &lt;route&gt;
            &lt;from uri="direct:start"/&gt;
            &lt;to uri="direct:foo"/&gt;
            &lt;to uri="log:foo"/&gt;
            &lt;to uri="mock:result"/&gt;
        &lt;/route&gt;

        &lt;route&gt;
            &lt;from uri="direct:foo"/&gt;
            &lt;transform&gt;
                &lt;constant&gt;Bye World&lt;/constant&gt;
            &lt;/transform&gt;
        &lt;/route&gt;

    &lt;/camelContext&gt;</code></pre> </div> </div> <div class="paragraph"> <p>Then we create a new XML file as follows, where we include the <code>camel-route.xml</code> file and define a spring bean with the class <code>org.apache.camel.impl.InterceptSendToMockEndpointStrategy</code> which tells Camel to mock all endpoints:</p> </div> <div class="listingblock"> <div class="title"><strong>test-camel-route.xml</strong></div> <div class="content"> <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;!-- the Camel route is defined in another XML file --&gt;
    &lt;import resource="camel-route.xml"/&gt;

    &lt;!-- bean which enables mocking all endpoints --&gt;
    &lt;bean id="mockAllEndpoints" class="org.apache.camel.impl.engine.InterceptSendToMockEndpointStrategy"/&gt;</code></pre> </div> </div> <div class="paragraph"> <p>Then in your unit test you load the new XML file (<code>test-camel-route.xml</code>) instead of <code>camel-route.xml</code>.</p> </div> <div class="paragraph"> <p>To only mock all <a href="log-component.html" class="page">Log</a> endpoints you can define the pattern in the constructor for the bean:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;bean id="mockAllEndpoints" class="org.apache.camel.impl.InterceptSendToMockEndpointStrategy"&gt;
    &lt;constructor-arg index="0" value="log*"/&gt;
&lt;/bean&gt;</code></pre> </div> </div> </div> </div> <div class="sect1"> <h2 id="_mocking_endpoints_and_skip_sending_to_original_endpoint"><a class="anchor" href="#_mocking_endpoints_and_skip_sending_to_original_endpoint"></a>Mocking endpoints and skip sending to original endpoint</h2> <div class="sectionbody"> <div class="paragraph"> <p>Sometimes you want to easily mock and skip sending to a certain endpoints. So the message is detoured and send to the mock endpoint only. You can now use the <code>mockEndpointsAndSkip</code> method using AdviceWith. The example below will skip sending to the two endpoints <code>"direct:foo"</code>, and <code>"direct:bar"</code>.</p> </div> <div class="listingblock"> <div class="title"><strong>adviceWith mock and skip sending to endpoints</strong></div> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Test
    public void testAdvisedMockEndpointsWithSkip() throws Exception {
        // advice the first route using the inlined AdviceWith route builder
        // which has extended capabilities than the regular route builder
        RouteReifier.adviceWith(context.getRouteDefinitions().get(0), context, new AdviceWithRouteBuilder() {
            @Override
            public void configure() throws Exception {
                // mock sending to direct:foo and direct:bar and skip send to it
                mockEndpointsAndSkip("direct:foo", "direct:bar");
            }
        });

        getMockEndpoint("mock:result").expectedBodiesReceived("Hello World");
        getMockEndpoint("mock:direct:foo").expectedMessageCount(1);
        getMockEndpoint("mock:direct:bar").expectedMessageCount(1);

        template.sendBody("direct:start", "Hello World");

        assertMockEndpointsSatisfied();

        // the message was not send to the direct:foo route and thus not sent to
        // the seda endpoint
        SedaEndpoint seda = context.getEndpoint("seda:foo", SedaEndpoint.class);
        assertEquals(0, seda.getCurrentQueueSize());
    }</code></pre> </div> </div> <div class="paragraph"> <p>The same example using the Test Kit</p> </div> <div class="listingblock"> <div class="title"><strong>isMockEndpointsAndSkip using camel-test kit</strong></div> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class IsMockEndpointsAndSkipJUnit4Test extends CamelTestSupport {

    @Override
    public String isMockEndpointsAndSkip() {
        // override this method and return the pattern for which endpoints to mock,
        // and skip sending to the original endpoint.
        return "direct:foo";
    }

    @Test
    public void testMockEndpointAndSkip() throws Exception {
        // notice we have automatic mocked the direct:foo endpoints and the name of the endpoints is "mock:uri"
        getMockEndpoint("mock:result").expectedBodiesReceived("Hello World");
        getMockEndpoint("mock:direct:foo").expectedMessageCount(1);

        template.sendBody("direct:start", "Hello World");

        assertMockEndpointsSatisfied();

        // the message was not send to the direct:foo route and thus not sent to the seda endpoint
        SedaEndpoint seda = context.getEndpoint("seda:foo", SedaEndpoint.class);
        assertEquals(0, seda.getCurrentQueueSize());
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct:start").to("direct:foo").to("mock:result");

                from("direct:foo").transform(constant("Bye World")).to("seda:foo");
            }
        };
    }
}</code></pre> </div> </div> </div> </div> <div class="sect1"> <h2 id="_limiting_the_number_of_messages_to_keep"><a class="anchor" href="#_limiting_the_number_of_messages_to_keep"></a>Limiting the number of messages to keep</h2> <div class="sectionbody"> <div class="paragraph"> <p>The <a href="#">Mock</a> endpoints will by default keep a copy of every Exchange that it received. So if you test with a lot of messages, then it will consume memory.<br> We have introduced two options <code>retainFirst</code> and <code>retainLast</code> that can be used to specify to only keep N&#8217;th of the first and/or last Exchanges.</p> </div> <div class="paragraph"> <p>For example in the code below, we only want to retain a copy of the first 5 and last 5 Exchanges the mock receives.</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">  MockEndpoint mock = getMockEndpoint("mock:data");
  mock.setRetainFirst(5);
  mock.setRetainLast(5);
  mock.expectedMessageCount(2000);

  mock.assertIsSatisfied();</code></pre> </div> </div> <div class="paragraph"> <p>Using this has some limitations. The <code>getExchanges()</code> and <code>getReceivedExchanges()</code> methods on the <code>MockEndpoint</code> will return only the retained copies of the Exchanges. So in the example above, the list will contain 10 Exchanges; the first five, and the last five.<br> The <code>retainFirst</code> and <code>retainLast</code> options also have limitations on which expectation methods you can use. For example the <code>expectedXXX</code> methods that work on message bodies, headers, etc. will only operate on the retained messages. In the example above they can test only the expectations on the 10 retained messages.</p> </div> </div> </div> <div class="sect1"> <h2 id="_testing_with_arrival_times"><a class="anchor" href="#_testing_with_arrival_times"></a>Testing with arrival times</h2> <div class="sectionbody"> <div class="paragraph"> <p>The <a href="#">Mock</a> endpoint stores the arrival time of the message as a property on the Exchange.</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Date time = exchange.getProperty(Exchange.RECEIVED_TIMESTAMP, Date.class);</code></pre> </div> </div> <div class="paragraph"> <p>You can use this information to know when the message arrived on the mock. But it also provides foundation to know the time interval between the previous and next message arrived on the mock. You can use this to set expectations using the <code>arrives</code> DSL on the <a href="#">Mock</a> endpoint.</p> </div> <div class="paragraph"> <p>For example to say that the first message should arrive between 0-2 seconds before the next you can do:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mock.message(0).arrives().noLaterThan(2).seconds().beforeNext();</code></pre> </div> </div> <div class="paragraph"> <p>You can also define this as that 2nd message (0 index based) should arrive no later than 0-2 seconds after the previous:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mock.message(1).arrives().noLaterThan(2).seconds().afterPrevious();</code></pre> </div> </div> <div class="paragraph"> <p>You can also use between to set a lower bound. For example suppose that it should be between 1-4 seconds:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mock.message(1).arrives().between(1, 4).seconds().afterPrevious();</code></pre> </div> </div> <div class="paragraph"> <p>You can also set the expectation on all messages, for example to say that the gap between them should be at most 1 second:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">mock.allMessages().arrives().noLaterThan(1).seconds().beforeNext();</code></pre> </div> </div> <div class="admonitionblock tip"> <div class="table-wrapper"><table> <tr> <td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td> <td class="content"> <strong>Time units</strong><br> In the example above we use <code>seconds</code> as the time unit, but Camel offers <code>milliseconds</code>, and <code>minutes</code> as well. </td> </tr> </table></div> </div> </div> </div> </article> </main> </div> <footer> <div class="footer"> <figure class="logo"> <img src="../../_/img/logo-d.svg" class="logo-small mt-60" alt="Apache Camel Logo" aria-label="white silhouette of a camel in front of a sand dune"> </figure> <dl> <dt>Overview</dt> <dd><a href="../../blog/">Blog</a></dd> <dd><a href="../../components/latest/">Components</a></dd> <dd><a href="../../download/">Download</a></dd> <dd><a href="../../docs/getting-started/">Getting started</a></dd> <dd><a href="../../manual/latest/faq.html">FAQ</a></dd> </dl> <dl> <dt>Community</dt> <dd><a href="../../community/support/">Support</a></dd> <dd><a href="https://github.com/apache/camel/blob/master/CONTRIBUTING.md">Contributing</a></dd> <dd><a href="../../community/user-stories/">User stories</a></dd> <dd><a href="../../community/articles/">Articles</a></dd> <dd><a href="../../community/books/">Books</a></dd> <dd><a href="../../community/team/">Team</a></dd> </dl> <dl> <dt>About</dt> <dd><a href="../../acknowledgments/">Acknowledgments</a> </dd><dd><a target="_blank" href="https://www.apache.org/events/current-event.html" title="Apache Events">Apache Events</a></dd> <dd><a target="_blank" href="https://www.apache.org/licenses/" title="License">License</a></dd> <dd><a target="_blank" href="https://www.apache.org/security/" title="Security">Security</a></dd> <dd><a target="_blank" href="https://www.apache.org/foundation/sponsorship.html" title="Sponsorship">Sponsorship</a></dd> <dd><a target="_blank" href="https://www.apache.org/foundation/thanks.html" title="Thanks">Thanks</a></dd> </dl> <p> &copy; 2004-2019 The <a href="https://apache.org">Apache Software Foundation</a>.<br> Apache Camel, Camel, Apache, the Apache feather logo, and the Apache Camel project logo are trademarks of The Apache Software Foundation. All other marks mentioned may be trademarks or registered trademarks of their respective owners. </p> </div> </footer> <script src="../../_/js/site-f4f4dbc142.js"></script> <script async src="../../_/js/vendor/highlight-54157f17f1.js"></script> <script async src="../../_/js/vendor/svg4everybody-195d47ce7d.js"></script> <script type="application/ld+json"> {
  "@context": "http://schema.org",
  "@type": "Organization",
  "name": "Apache Camel",
  "url": "https://camel.apache.org",
  "sameAs": [
     "https://twitter.com/ApacheCamel"
  ],
  "logo": "../../_/img/logo-d.svg",
  "description": "Apache Camel ™ is a versatile open-source integration framework based on known Enterprise Integration Patterns. Camel empowers you to define routing and mediation rules in a variety of domain-specific languages, including a Java-based Fluent API, Spring or Blueprint XML Configuration files, and a Scala DSL."
} </script> <script type="application/ld+json"> { 
    "@context": "http://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "name": "Apache Camel",
        "item": "https://camel.apache.org"
        },
        {
        "@type": "ListItem",
        "position": 2,
        "name": "Component reference",
        "item": "https://camel.apache.org/components/latest/index.html"
        },
        {
        "@type": "ListItem",
        "position": 3,
        "name": "Mock Component","item": "https://camel.apache.org/components/latest/mock-component.html"}
        ]
    } </script> </body> </html> 