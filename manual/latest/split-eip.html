<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Untitled :: Apache Camel</title><link rel="canonical" href="https://camel.apache.org/staging/manual/latest/split-eip.html"><meta name="generator" content="Antora 2.0.0"><link rel="stylesheet" href="../../_/css/site.css"></head><body class="article"><header class="header"><nav class="navbar shadow border-bottom"><div class="navbar-brand"><a class="navbar-item nav-logo" href="../.." title="Apache Camel"></a><button class="navbar-burger" data-target="topbar-nav"><span></span><span></span><span></span></button></div><div id="topbar-nav" class="navbar-menu"><div class="navbar-end"><a class="navbar-item" href="../../">Home</a><a class="navbar-item" href="../../news/">News</a><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link" href="../..#">Projects</a><div class="navbar-dropdown"><a class="navbar-item" href="../../projects/camel-k/">Camel K</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link" href="../..#">Documentation</a><div class="navbar-dropdown"><a class="navbar-item" href="../../docs/getting-started/">Getting started</a><a class="navbar-item" href="../../manual/latest/">User manual</a><a class="navbar-item" href="../../components/latest/">Component reference</a><a class="navbar-item" href="../../camel-k/latest/">Camel K</a></div></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link" href="../..#">Community</a><div class="navbar-dropdown"><a class="navbar-item" href="../../community/support/">Support</a><a class="navbar-item" href="../..https://github.com/apache/camel/blob/master/CONTRIBUTING.md">Contributing</a><a class="navbar-item" href="../../community/user-stories/">User stories</a><a class="navbar-item" href="../../community/articles/">Articles</a><a class="navbar-item" href="../../community/books/">Books</a><a class="navbar-item" href="../../community/team/">Team</a><a class="navbar-item" href="../../community/camel-extra/">Camel extra</a></div></div><a class="navbar-item" href="../../download/">Download</a><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link" href="../..#">About</a><div class="navbar-dropdown"><a class="navbar-item" href="../..https://www.apache.org/events/current-event.html">Apache events</a><a class="navbar-item" href="../..https://www.apache.org/licenses/">License</a><a class="navbar-item" href="../../security/">Security</a><a class="navbar-item" href="../..https://www.apache.org/foundation/sponsorship.html">Sponsorship</a><a class="navbar-item" href="../..https://www.apache.org/foundation/thanks.html">Thanks</a></div></div></div></div></nav></header><div class="main-wrapper"><div class="navigation-container" data-component="manual" data-version="latest"><aside class="navigation"><div class="panels"><div class="navigation-menu is-active" data-panel="menu"><nav class="nav-menu"><h3 class="title"><a href="index.html">User manual</a></h3><ul class="nav-list"><li class="nav-item" data-depth="0"><ul class="nav-list"><li class="nav-item" data-depth="1"><button class="nav-toggle"></button><a class="nav-link" href="getting-started.html">Getting started</a><ul class="nav-list"><li class="nav-item" data-depth="2"><a class="nav-link" href="book-getting-started.html">Getting Started with Apache Camel</a></li></ul></li><li class="nav-item" data-depth="1"><button class="nav-toggle"></button><a class="nav-link" href="architecture.html">Architecture</a><ul class="nav-list"><li class="nav-item" data-depth="2"><a class="nav-link" href="async.html">Async</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="asynchronous-routing-engine.html">Asynchronous Routing Engine</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="backlogdebugger.html">Backlog debugger</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="bam.html">Business Activity Monitoring</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="batch-consumer.html">Batch Consumer</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="browsable-endpoint.html">BrowsableEndpoint</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="camel-core.html">Core</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="camelcontext.html">Context</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="endpoint.html">Endpoints</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="cep.html">Complex Event Processing</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="component.html">Component</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="debugger.html">Debugger</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="delay-interceptor.html">Delay interceptor</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="dependency-injection.html">Dependency Injection</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="dozer-type-conversion.html">Dozer Type Conversion</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="bean-integration.html">Bean Integration</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="error-handler.html">Error Handler</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="exchange.html">Message Exchange</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="exchange-pattern.html">Exchange Pattern</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="expression.html">Expressions</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="injector.html">Injector</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="intercept.html">Intercept</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="inversion-of-control-with-smart-defaults.html">Inversion Of Control With Smart Defaults</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="jmx.html">JMX</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="lifecycle.html">Camel Lifecycle</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="oncompletion.html">OnCompletion</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="predicate.html">Predicates</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="registry.html">Registry</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="route-builder.html">RouteBuilder</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="routes.html">Routes</a></li></ul></li><li class="nav-item" data-depth="1"><button class="nav-toggle"></button><span class="nav-text">Domain Specific Languages</span><ul class="nav-list"><li class="nav-item" data-depth="2"><a class="nav-link" href="dsl.html">Camel Domain Specific Language</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="java-dsl.html">Java DSL</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="spring.html">Spring support</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="groovy-dsl.html">Groovy DSL</a></li></ul></li><li class="nav-item" data-depth="1"><a class="nav-link" href="using-osgi-blueprint-with-camel.html">Using OSGi blueprint with Camel</a></li><li class="nav-item" data-depth="1"><button class="nav-toggle"></button><span class="nav-text">Camel Core Features</span><ul class="nav-list"><li class="nav-item" data-depth="2"><a class="nav-link" href="bean-language.html">Bean method Language</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="clustering.html">Clustering</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="constant-language.html">Constant Language</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="dynamic-router.html">Dynamic Router</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="exchangeProperty-language.html">ExchangeProperty Language</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="file-language.html">File Language</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="header-language.html">Header Language</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="health-check.html">Health Check</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="ref-language.html">Ref Language</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="rest-dsl.html">REST DSL Component</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="return-address.html">Return Address</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="service-registry.html">Service Registry</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="simple-language.html">Simple Language</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="tokenize-language.html">Tokenize Language</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="transformer.html">Transformer</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="validator.html">Validator</a></li></ul></li><li class="nav-item" data-depth="1"><button class="nav-toggle"></button><a class="nav-link" href="enterprise-integration-patterns.html">Enterprise Integration Patterns</a><ul class="nav-list"><li class="nav-item" data-depth="2"><a class="nav-link" href="aggregate-eip.html">Aggregate EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="batch-config-eip.html">Batch-config EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="bean-eip.html">Bean EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="choice-eip.html">Choice EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="circuitBreaker-eip.html">Circuit Breaker EIP (deprecated)</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="claimCheck-eip.html">Claim Check EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="content-based-router-eip.html">Content Based Router</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="content-filter-eip.html">Content Filter</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="convertBodyTo-eip.html">Convert Body To EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="correlation-identifier.html">Correlation Identifier</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="customLoadBalancer-eip.html">Custom Load Balancer EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="dead-letter-channel.html">Dead Letter Channel</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="delay-eip.html">Delay EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="dynamicRouter-eip.html">Dynamic Router EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="enrich-eip.html">Enrich EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="event-message.html">Event Message</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="eventDrivenConsumer-eip.html">Event Driven Consumer</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="failover-eip.html">Failover EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="filter-eip.html">Filter EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="from-eip.html">From EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="guaranteed-delivery.html">Guaranteed Delivery</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="hystrix-eip.html">Hystrix EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="hystrixConfiguration-eip.html">Hystrix Configuration EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="idempotentConsumer-eip.html">Idempotent Consumer EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="inOnly-eip.html">In Only EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="inOut-eip.html">In Out EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="loadBalance-eip.html">Load Balance EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="log-eip.html">Log EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="loop-eip.html">Loop EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="marshal-eip.html">Marshal EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="message-bus.html">Message Bus</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="message-channel.html">Message Channel</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="message-endpoint.html">Message Endpoint</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="message-router.html">Message Router</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="message-translator.html">Message Translator</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="message.html">Message</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="multicast-eip.html">Multicast EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="onFallback-eip.html">On Fallback EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="otherwise-eip.html">Otherwise EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="pipeline-eip.html">Pipeline EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="point-to-point-channel.html">Point to Point Channel</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="pollEnrich-eip.html">Poll Enrich EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="process-eip.html">Process EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="publish-subscribe-channel.html">Publish Subscribe Channel</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="random-eip.html">Random EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="recipientList-eip.html">Recipient List EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="removeHeader-eip.html">Remove Header EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="removeHeaders-eip.html">Remove Headers EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="removeProperties-eip.html">Remove Properties EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="removeProperty-eip.html">Remove Property EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="requestReply-eip.html">Request Reply</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="resequence-eip.html">Resequence EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="rollback-eip.html">Rollback EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="roundRobin-eip.html">Round Robin EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="routingSlip-eip.html">Routing Slip EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="saga-eip.html">Saga EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="sample-eip.html">Sample EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="script-eip.html">Script EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="serviceCall-eip.html">Service Call EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="setBody-eip.html">Set Body EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="setFaultBody-eip.html">Set Fault Body EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="setHeader-eip.html">Set Header EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="setOutHeader-eip.html">Set Out Header EIP (deprecated)</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="setProperty-eip.html">Set Property EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="sort-eip.html">Sort EIP</a></li><li class="nav-item is-current-page" data-depth="2"><a class="nav-link" href="split-eip.html">Split EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="step-eip.html">Step EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="sticky-eip.html">Sticky EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="stop-eip.html">Stop EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="stream-config-eip.html">Stream-config EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="threads-eip.html">Threads EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="throttle-eip.html">Throttle EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="to-eip.html">To EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="toD-eip.html">To D EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="topic-eip.html">Topic EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="transactional-client.html">Transactional Client</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="transform-eip.html">Transform EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="unmarshal-eip.html">Unmarshal EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="validate-eip.html">Validate EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="weighted-eip.html">Weighted EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="when-eip.html">When EIP</a></li><li class="nav-item" data-depth="2"><a class="nav-link" href="wireTap-eip.html">Wire Tap EIP</a></li></ul></li></ul></li></ul></nav></div><div class="navigation-explore" data-panel="explore"><div class="context"><span class="title">User manual</span><span class="version">latest</span></div><ul class="components"><li class="component"><span class="title">Apache Camel K</span><ul class="versions"><li class="version is-latest"><a href="../../camel-k/latest/index.html">latest</a></li></ul></li><li class="component"><span class="title">Component reference</span><ul class="versions"><li class="version is-latest"><a href="../../components/latest/index.html">latest</a></li></ul></li><li class="component is-current"><span class="title">User manual</span><ul class="versions"><li class="version is-current is-latest"><a href="index.html">latest</a></li></ul></li></ul></div></div></aside></div><main class="main"><div class="toolbar" role="navigation"><button class="navigation-toggle"></button><a href="index.html" class="home-link"></a><nav class="crumbs" aria-label="breadcrumbs"><ul><li class="crumb"><a href="index.html">User manual</a></li><li class="crumb"><a href="enterprise-integration-patterns.html">Enterprise Integration Patterns</a></li><li class="crumb"><a href="split-eip.html">Split EIP</a></li></ul></nav><div class="edit-this-page"><a href="https://github.com/apache/camel/edit/master/docs/user-manual/modules/ROOT/pages/split-eip.adoc">Edit this Page</a></div></div><article class="doc"><div class="sect1"><h2 id="split-eip"><a class="anchor" href="#split-eip"></a>Split EIP</h2><div class="sectionbody"><div class="paragraph"><p>The<a href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/Sequencer.html">Splitter</a>from the<a href="enterprise-integration-patterns.html">EIP patterns</a>allows you split a message into a number of pieces and process them individually.</p></div><div class="paragraph"><p><span class="image"><img src="http://www.enterpriseintegrationpatterns.com/img/Sequencer.gif" alt="image"></span></p></div><div class="paragraph"><p>You need to specify a Splitter as<code>split()</code>. In earlier versions of Camel, you need to use<code>splitter()</code>.</p></div><div class="paragraph"><p>The Split EIP supports 12 options which are listed below:</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width: 20%;"><col style="width: 50%;"><col style="width: 10%;"><col style="width: 20%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Name</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-center valign-top">Default</th><th class="tableblock halign-left valign-top">Type</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>parallelProcessing</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If enabled then processing each splitted messages occurs concurrently. Note the caller thread will still wait until all messages has been fully processed, before it continues. Its only processing the sub messages from the splitter which happens concurrently.</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>strategyRef</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Sets a reference to the AggregationStrategy to be used to assemble the replies from the splitted messages, into a single outgoing message from the Splitter. By default Camel will use the original incoming message to the splitter (leave it unchanged). You can also use a POJO as the AggregationStrategy</p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>strategyMethodName</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This option can be used to explicit declare the method name to use, when using POJOs as the AggregationStrategy.</p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>strategyMethodAllowNull</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>executorServiceRef</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Refers to a custom Thread Pool to be used for parallel processing. Notice if you set this option, then parallel processing is automatic implied, and you do not have to enable that option as well.</p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>streaming</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">When in streaming mode, then the splitter splits the original message on-demand, and each splitted message is processed one by one. This reduces memory usage as the splitter do not split all the messages first, but then we do not know the total size, and therefore the org.apache.camel.Exchange#SPLIT_SIZE is empty. In non-streaming mode (default) the splitter will split each message first, to know the total size, and then process each message one by one. This requires to keep all the splitted messages in memory and therefore requires more memory. The total size is provided in the org.apache.camel.Exchange#SPLIT_SIZE header. The streaming mode also affects the aggregation behavior. If enabled then Camel will process replies out-of-order, eg in the order they come back. If disabled, Camel will process replies in the same order as the messages was splitted.</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>stopOnException</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Will now stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message) or an exception was thrown and handled by the error handler (such as using onException). In all situations the splitter will stop further processing. This is the same behavior as in pipeline, which is used by the routing engine. The default behavior is to not stop but continue processing till the end</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>timeout</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Sets a total timeout specified in millis, when using parallel processing. If the Splitter hasn&#8217;t been able to split and process all the sub messages within the given timeframe, then the timeout triggers and the Splitter breaks out and continues. Notice if you provide a TimeoutAwareAggregationStrategy then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining, certain tasks for which it is difficult for Camel to shut down in a graceful manner may continue to run. So use this option with a bit of care.</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">0</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>onPrepareRef</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Uses the Processor when preparing the org.apache.camel.Exchange to be send. This can be used to deep-clone messages that should be send, or any custom logic needed before the exchange is send.</p></td><td class="tableblock halign-center valign-top"></td><td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>shareUnitOfWork</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Splitter will by default not share unit of work between the parent exchange and each splitted exchange. This means each splitted exchange has its own individual unit of work.</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>parallelAggregate</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default this is false meaning that Camel synchronizes the call to the aggregate method. Though in some use-cases this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>stopOnAggregateException</strong></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If enabled, unwind exceptions occurring at aggregation time to the error handler when parallelProcessing is used. Currently, aggregation time exceptions do not stop the route processing when parallelProcessing is used. Enabling this option allows to work around this behavior. The default value is false for the sake of backward compatibility.</p></td><td class="tableblock halign-center valign-top"><p class="tableblock">false</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td></tr></tbody></table><div class="sect2"><h3 id="_exchange_properties"><a class="anchor" href="#_exchange_properties"></a>Exchange properties</h3><div class="paragraph"><p>The following properties are set on each Exchange that are split:</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width: 30%;"><col style="width: 10%;"><col style="width: 60%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Property</th><th class="tableblock halign-left valign-top">Type</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>CamelSplitIndex</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code><code>int</code></code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A split counter that increases for each Exchange being split. The counter starts from 0.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>CamelSplitSize</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code><code>int</code></code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The total number of Exchanges that was splitted. This header is not applied for stream based splitting. From<strong>Camel 2.9</strong>onwards this header is also set in stream based splitting, but only on the completed Exchange.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><code>CamelSplitComplete</code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><code><code>boolean</code></code></p></td><td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Camel 2.4</strong>: Whether or not this Exchange is the last.</p></td></tr></tbody></table></div><div class="sect2"><h3 id="_examples"><a class="anchor" href="#_examples"></a>Examples</h3><div class="paragraph"><p>The following example shows how to take a request from the<strong>direct:a</strong>endpoint the split it into pieces using an Expression, then forward each piece to<strong>direct:b</strong></p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:a")
    .split(body(String.class).tokenize("\n"))
        .to("direct:b");</code></pre></div></div><div class="paragraph"><p>The splitter can use any Expression language so you could use any of the Languages Supported such as XPath, XQuery, SQL or one of the Scripting Languages to perform the split. e.g.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("activemq:my.queue")
    .split(xpath("//foo/bar"))
        .to("file://some/directory")</code></pre></div></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;route&gt;
        &lt;from uri="activemq:my.queue"/&gt;
        &lt;split&gt;
            &lt;xpath&gt;//foo/bar&lt;/xpath&gt;
            &lt;to uri="file://some/directory"/&gt;
        &lt;/split&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre></div></div></div><div class="sect2"><h3 id="_splitting_a_collection_iterator_or_array"><a class="anchor" href="#_splitting_a_collection_iterator_or_array"></a>Splitting a Collection, Iterator or Array</h3><div class="paragraph"><p>A common use case is to split a Collection, Iterator or Array from the message. In the sample below we simply use an Expression to identify the value to split.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:splitUsingBody")
    .split(body())
        .to("mock:result");

from("direct:splitUsingHeader")
    .split(header("foo"))
        .to("mock:result");</code></pre></div></div><div class="paragraph"><p>In XML you can use the Simple language to identify the value to split.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
  &lt;from uri="direct:splitUsingBody"/&gt;
  &lt;split&gt;
     &lt;simple&gt;${body}&lt;/simple&gt;
     &lt;to uri="mock:result"/&gt;
  &lt;/split&gt;
&lt;/route&gt;

&lt;route&gt;
  &lt;from uri="direct:splitUsingHeader"/&gt;
  &lt;split&gt;
     &lt;simple&gt;${header.foo}&lt;/simple&gt;
     &lt;to uri="mock:result"/&gt;
  &lt;/split&gt;
&lt;/route&gt;</code></pre></div></div></div><div class="sect2"><h3 id="_using_tokenizer_from_spring_xml_extensions"><a class="anchor" href="#_using_tokenizer_from_spring_xml_extensions"></a>Using Tokenizer from Spring XML Extensions*</h3><div class="paragraph"><p>You can use the tokenizer expression in the Spring DSL to split bodies or headers using a token. This is a common use-case, so we provided a special<strong>tokenizer</strong>tag for this. In the sample below we split the body using a<code>@</code>as separator. You can of course use comma or space or even a regex pattern, also set<code>regex=true</code>.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;route&gt;
        &lt;from uri="direct:start"/&gt;
        &lt;split&gt;
            &lt;tokenize token="@"/&gt;
            &lt;to uri="mock:result"/&gt;
        &lt;/split&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre></div></div></div><div class="sect2"><h3 id="_what_the_splitter_returns"><a class="anchor" href="#_what_the_splitter_returns"></a>What the Splitter returns</h3><div class="paragraph"><p>The Splitter will by default return the original input message.</p></div><div class="paragraph"><p>You can override this by suppling your own strategy as an<code>AggregationStrategy</code>. There is a sample on this page (Split aggregate request/reply sample). Notice its the same strategy as the Aggregate EIP supports. This Splitter can be viewed as having a build in light weight Aggregate EIP.</p></div></div><div class="sect2"><h3 id="_parallel_execution_of_distinct_parts"><a class="anchor" href="#_parallel_execution_of_distinct_parts"></a>Parallel execution of distinct parts</h3><div class="paragraph"><p>If you want to execute all parts in parallel you can use the<code>parallelProcessing</code>option as show:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">XPathBuilder xPathBuilder = new XPathBuilder("//foo/bar");

from("activemq:my.queue")
  .split(xPathBuilder).parallelProcessing()
    .to("activemq:my.parts");</code></pre></div></div></div><div class="sect2"><h3 id="_stream_based"><a class="anchor" href="#_stream_based"></a>Stream based</h3><div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="title">Splitting big XML payloads</div><div class="paragraph"><p>The XPath engine in Java and saxon will load the entire XML content into memory. And thus they are not well suited for very big XML payloads. Instead you can use a custom Expression which will iterate the XML payload in a streamed fashion. From Camel 2.9 onwards you can use the Tokenizer language which supports this when you supply the start and end tokens. From Camel 2.14, you can use the XMLTokenizer language which is specifically provided for tokenizing XML documents.</p></div></td></tr></table></div><div class="paragraph"><p>You can split streams by enabling the streaming mode using the streaming builder method.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:streaming")
  .split(body().tokenize(",")).streaming()
    .to("activemq:my.parts");</code></pre></div></div><div class="paragraph"><p>You can also supply your custom Bean as the splitter to use with streaming like this:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:streaming")
  .split(method(new MyCustomIteratorFactory(), "iterator")) .streaming()
    .to("activemq:my.parts")</code></pre></div></div></div><div class="sect2"><h3 id="_streaming_big_xml_payloads_using_tokenizer_language"><a class="anchor" href="#_streaming_big_xml_payloads_using_tokenizer_language"></a>Streaming big XML payloads using Tokenizer language</h3><div class="paragraph"><p>There are two tokenizers that can be used to tokenize an XML payload. The first tokenizer uses the same principle as in the text tokenizer to scan the XML payload and extract a sequence of tokens.</p></div><div class="paragraph"><p><strong>Available as of Camel 2.9</strong></p></div><div class="paragraph"><p>If you have a big XML payload, from a file source, and want to split it in streaming mode, then you can use the Tokenizer language with start/end tokens to do this with low memory footprint.</p></div><div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="title">StAX component</div><div class="paragraph"><p>The Camel StAX component can also be used to split big XML files in a streaming mode. See more details at StAX.</p></div></td></tr></table></div><div class="paragraph"><p>For example you may have a XML payload structured as follows</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;orders&gt;
  &lt;order&gt;
    &lt;!-- order stuff here --&gt;
  &lt;/order&gt;
  &lt;order&gt;
    &lt;!-- order stuff here --&gt;
  &lt;/order&gt;
...
  &lt;order&gt;
    &lt;!-- order stuff here --&gt;
  &lt;/order&gt;
&lt;/orders&gt;</code></pre></div></div><div class="paragraph"><p>Now to split this big file using XPath would cause the entire content to be loaded into memory. So instead we can use the Tokenizer language to do this as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("file:inbox")
  .split().tokenizeXML("order").streaming()
     .to("activemq:queue:order");</code></pre></div></div><div class="paragraph"><p>In XML DSL the route would be as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
  &lt;from uri="file:inbox"/&gt;
  &lt;split streaming="true"&gt;
    &lt;tokenize token="order" xml="true"/&gt;
    &lt;to uri="activemq:queue:order"/&gt;
  &lt;/split&gt;
&lt;/route&gt;</code></pre></div></div><div class="paragraph"><p>Notice the<code>tokenizeXML</code>method which will split the file using the tag name of the child node (more precisely speaking, the local name of the element without its namespace prefix if any), which mean it will grab the content between the &lt;order&gt; and &lt;/order&gt; tags (incl. the tokens). So for example a splitted message would be as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;order&gt;
  &lt;!-- order stuff here --&gt;
&lt;/order&gt;</code></pre></div></div><div class="paragraph"><p>If you want to inherit namespaces from a root/parent tag, then you can do this as well by providing the name of the root/parent tag:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
  &lt;from uri="file:inbox"/&gt;
  &lt;split streaming="true"&gt;
    &lt;tokenize token="order" inheritNamespaceTagName="orders" xml="true"/&gt;
    &lt;to uri="activemq:queue:order"/&gt;
  &lt;/split&gt;
&lt;/route&gt;</code></pre></div></div><div class="paragraph"><p>And in Java DSL its as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("file:inbox")
  .split().tokenizeXML("order", "orders").streaming()
     .to("activemq:queue:order");</code></pre></div></div><div class="paragraph"><p>Available as of Camel 2.13.1, you can set the above<code>inheritNamsepaceTagName</code>property to<code>*</code>to include the preceding context in each token (i.e., generating each token enclosed in its ancestor elements). It is noted that each token must share the same ancestor elements in this case.</p></div><div class="paragraph"><p>The above tokenizer works well on simple structures but has some inherent limitations in handling more complex XML structures.</p></div><div class="paragraph"><p><strong>Available as of Camel 2.14</strong></p></div><div class="paragraph"><p>The second tokenizer uses a StAX parser to overcome these limitations. This tokenizer recognizes XML namespaces and also handles simple and complex XML structures more naturally and efficiently.</p></div><div class="paragraph"><p>To split using this tokenizer at {urn:shop}order, we can write</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Namespaces ns = new Namespaces("ns1", "urn:shop");
...
from("file:inbox")
  .split().xtokenize("//ns1:order", 'i', ns).streaming()
    .to("activemq:queue:order)</code></pre></div></div><div class="paragraph"><p>Two arguments control the behavior of the tokenizer. The first argument specifies the element using a path notation. This path notation uses a subset of xpath with wildcard support. The second argument represents the extraction mode. The available extraction modes are:</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width: 33.3333%;"><col style="width: 66.6667%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Mode</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">i</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">injecting the contextual namespace bindings into the extracted token (default)</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">w</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">wrapping the extracted token in its ancestor context</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">u</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">unwrapping the extracted token to its child content</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">t</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">extracting the text content of the specified element</p></td></tr></tbody></table><div class="paragraph"><p>Having an input XML</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;m:orders xmlns:m="urn:shop" xmlns:cat="urn:shop:catalog"&gt;
  &lt;m:order&gt;&lt;id&gt;123&lt;/id&gt;&lt;date&gt;2014-02-25&lt;/date&gt;...&lt;/m:order&gt;
...
&lt;/m:orders&gt;</code></pre></div></div><div class="paragraph"><p>Each mode will result in the following tokens,</p></div><table class="tableblock frame-all grid-all stretch"><colgroup><col style="width: 33.3333%;"><col style="width: 66.6667%;"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Mode</th><th class="tableblock halign-left valign-top">Description</th></tr></thead><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">i</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">&lt;m:order xmlns:m="urn:shop" xmlns:cat="urn:shop:catalog"&gt;&lt;id&gt;123&lt;/id&gt;&lt;date&gt;2014-02-25&lt;/date&gt;&#8230;&#8203;&lt;/m:order&gt;</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">w</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">&lt;m:orders xmlns:m="urn:shop" xmlns:cat="urn:shop:catalog"&gt;</p><p class="tableblock">&lt;m:order&gt;&lt;id&gt;123&lt;/id&gt;&lt;date&gt;2014-02-25&lt;/date&gt;&#8230;&#8203;&lt;/m:order&gt;</p><p class="tableblock">&lt;/m:orders&gt;</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">u</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">&lt;id&gt;123&lt;/id&gt;&lt;date&gt;2014-02-25&lt;/date&gt;&#8230;&#8203;</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">t</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">1232014-02-25&#8230;&#8203;</p></td></tr></tbody></table><div class="paragraph"><p>In XML DSL, the equivalent route would be written as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext xmlns:ns1="urn:shop"&gt;
  &lt;route&gt;
    &lt;from uri="file:inbox"/&gt;
    &lt;split streaming="true"&gt;
      &lt;xtokenize&gt;//ns1:order&lt;/xtokenize&gt;
      &lt;to uri="activemq:queue:order"/&gt;
    &lt;/split&gt;
  &lt;/route&gt;
&lt;/camelContext&gt;</code></pre></div></div><div class="paragraph"><p>or setting the extraction mode explicitly as</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;xtokenize mode="i"&gt;//ns1:order&lt;/xtokenize&gt;</code></pre></div></div><div class="paragraph"><p>Note that this StAX based tokenizer&#8217;s uses StAX Location API and requires a StAX Reader implementation (e.g., woodstox) that correctly returns the offset position pointing to the beginning of each event triggering segment (e.g., the offset position of<code>&lt;</code>at each start and end element event). If you use a StAX Reader which does not implement that API correctly it results in invalid xml snippets after the split. For example the snippet could be wrong terminated:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;Start&gt;...&lt;&lt;/Start&gt; .... &lt;Start&gt;...&lt;/&lt;/Start&gt;</code></pre></div></div></div><div class="sect2"><h3 id="_splitting_files_by_grouping_n_lines_together"><a class="anchor" href="#_splitting_files_by_grouping_n_lines_together"></a>Splitting files by grouping N lines together</h3><div class="paragraph"><p><strong>Available as of Camel 2.10</strong></p></div><div class="paragraph"><p>The Tokenizer language has a new option group that allows you to group N parts together, for example to split big files into chunks of 1000 lines.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("file:inbox")
  .split().tokenize("\n", 1000).streaming()
     .to("activemq:queue:order");</code></pre></div></div><div class="paragraph"><p>And in XML DSL</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
  &lt;from uri="file:inbox"/&gt;
  &lt;split streaming="true"&gt;
    &lt;tokenize token="\n" group="1000"/&gt;
    &lt;to uri="activemq:queue:order"/&gt;
  &lt;/split&gt;
&lt;/route&gt;</code></pre></div></div><div class="paragraph"><p>The group option is a number that must be a positive number that dictates how many groups to combine together. Each part will be combined using the token.</p></div><div class="paragraph"><p>So in the example above the message being sent to the activemq order queue, will contain 1000 lines, and each line separated by the token (which is a new line token).</p></div><div class="paragraph"><p>The output when using the group option is always a<code>java.lang.String</code>type.</p></div></div><div class="sect2"><h3 id="_specifying_a_custom_aggregation_strategy"><a class="anchor" href="#_specifying_a_custom_aggregation_strategy"></a>Specifying a custom aggregation strategy</h3><div class="paragraph"><p>This is specified similar to the Aggregate EIP.</p></div></div><div class="sect2"><h3 id="_specifying_a_custom_threadpoolexecutor"><a class="anchor" href="#_specifying_a_custom_threadpoolexecutor"></a>Specifying a custom ThreadPoolExecutor</h3><div class="paragraph"><p>You can customize the underlying<code>ThreadPoolExecutor</code>used in the parallel splitter via the<code>executorService</code>option. In the Java DSL try something like this:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">XPathBuilder xPathBuilder = new XPathBuilder("//foo/bar");

ExecutorService pool = ...

from("activemq:my.queue")
    .split(xPathBuilder).executorService(pool)
        .to("activemq:my.parts");</code></pre></div></div></div><div class="sect2"><h3 id="_using_a_pojo_to_do_the_splitting"><a class="anchor" href="#_using_a_pojo_to_do_the_splitting"></a>Using a Pojo to do the splitting</h3><div class="paragraph"><p>As the Splitter can use any Expression to do the actual splitting we leverage this fact and use a<strong>method</strong>expression to invoke a Bean to get the splitted parts.</p></div><div class="paragraph"><p>The Bean should return a value that is iterable such as:<code>java.util.Collection</code>,<code>java.util.Iterator</code>or an array.</p></div><div class="paragraph"><p>So the returned value, will then be used by Camel at runtime, to split the message.</p></div><div class="admonitionblock tip"><table><tr><td class="icon"><i class="fa icon-tip" title="Tip"></i></td><td class="content"><div class="title">Streaming mode and using pojo</div><div class="paragraph"><p>When you have enabled the streaming mode, then you should return a<code>Iterator</code>to ensure streamish fashion. For example if the message is a big file, then by using an iterator, that returns a piece of the file in chunks, in the next method of the<code>Iterator</code>ensures low memory footprint. This avoids the need for reading the entire content into memory. For an example see the source code for the TokenizePair implementation.</p></div></td></tr></table></div><div class="paragraph"><p>In the route we define the Expression as a method call to invoke our Bean that we have registered with the id mySplitterBean in the Registry.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:body")
    // here we use a POJO bean mySplitterBean to do the split of the payload
    .split().method("mySplitterBean", "splitBody")
      .to("mock:result");
from("direct:message")
    // here we use a POJO bean mySplitterBean to do the split of the message
    // with a certain header value
    .split().method("mySplitterBean", "splitMessage")
      .to("mock:result");</code></pre></div></div><div class="paragraph"><p>And the logic for our Bean is as simple as. Notice we use Camel Bean Binding to pass in the message body as a String object.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MySplitterBean {

    /**
     * The split body method returns something that is iteratable such as a java.util.List.
     *
     * @param body the payload of the incoming message
     * @return a list containing each part splitted
     */
    public List&lt;String&gt; splitBody(String body) {
        // since this is based on an unit test you can of cause
        // use different logic for splitting as Camel have out
        // of the box support for splitting a String based on comma
        // but this is for show and tell, since this is java code
        // you have the full power how you like to split your messages
        List&lt;String&gt; answer = new ArrayList&lt;String&gt;();
        String[] parts = body.split(",");
        for (String part : parts) {
            answer.add(part);
        }
        return answer;
    }

    /**
     * The split message method returns something that is iteratable such as a java.util.List.
     *
     * @param header the header of the incoming message with the name user
     * @param body the payload of the incoming message
     * @return a list containing each part splitted
     */
    public List&lt;Message&gt; splitMessage(@Header(value = "user") String header, @Body String body, CamelContext camelContext) {
        // we can leverage the Parameter Binding Annotations
        // http://camel.apache.org/parameter-binding-annotations.html
        // to access the message header and body at same time,
        // then create the message that we want, splitter will
        // take care rest of them.
        // *NOTE* this feature requires Camel version &gt;= 1.6.1
        List&lt;Message&gt; answer = new ArrayList&lt;Message&gt;();
        String[] parts = header.split(",");
        for (String part : parts) {
            DefaultMessage message = new DefaultMessage(camelContext);
            message.setHeader("user", part);
            message.setBody(body);
            answer.add(message);
        }
        return answer;
    }
}</code></pre></div></div></div><div class="sect2"><h3 id="_split_aggregate_requestreply_sample"><a class="anchor" href="#_split_aggregate_requestreply_sample"></a>Split aggregate request/reply sample</h3><div class="paragraph"><p>This sample shows how you can split an Exchange, process each splitted message, aggregate and return a combined response to the original caller using request/reply. The route below illustrates this and how the split supports a<code>aggregationStrategy</code>to hold the in progress processed messages:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// this routes starts from the direct:start endpoint
// the body is then splitted based on @ separator
// the splitter in Camel supports InOut as well and for that we need
// to be able to aggregate what response we need to send back, so we provide our
// own strategy with the class MyOrderStrategy.
from("direct:start")
    .split(body().tokenize("@"), new MyOrderStrategy())
        // each splitted message is then send to this bean where we can process it
        .to("bean:MyOrderService?method=handleOrder")
        // this is important to end the splitter route as we do not want to do more routing
        // on each splitted message
    .end()
    // after we have splitted and handled each message we want to send a single combined
    // response back to the original caller, so we let this bean build it for us
    // this bean will receive the result of the aggregate strategy: MyOrderStrategy
    .to("bean:MyOrderService?method=buildCombinedResponse")</code></pre></div></div><div class="paragraph"><p>And the OrderService bean is as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static class MyOrderService {

    private static int counter;

    /**
     * We just handle the order by returning a id line for the order
     */
    public String handleOrder(String line) {
        LOG.debug("HandleOrder: " + line);
        return "(id=" + ++counter + ",item=" + line + ")";
    }

    /**
     * We use the same bean for building the combined response to send
     * back to the original caller
     */
    public String buildCombinedResponse(String line) {
        LOG.debug("BuildCombinedResponse: " + line);
        return "Response[" + line + "]";
    }
}</code></pre></div></div><div class="paragraph"><p>And our custom<code>aggregationStrategy</code>that is responsible for holding the in progress aggregated message that after the splitter is ended will be sent to the<code>buildCombinedResponse</code>method for final processing before the combined response can be returned to the waiting caller.</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/**
 * This is our own order aggregation strategy where we can control
 * how each splitted message should be combined. As we do not want to
 * loos any message we copy from the new to the old to preserve the
 * order lines as long we process them
 */
public static class MyOrderStrategy implements AggregationStrategy {

    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        // put order together in old exchange by adding the order from new exchange

        if (oldExchange == null) {
            // the first time we aggregate we only have the new exchange,
            // so we just return it
            return newExchange;
        }

        String orders = oldExchange.getIn().getBody(String.class);
        String newLine = newExchange.getIn().getBody(String.class);

        LOG.debug("Aggregate old orders: " + orders);
        LOG.debug("Aggregate new order: " + newLine);

        // put orders together separating by semi colon
        orders = orders + ";" + newLine;
        // put combined order back on old to preserve it
        oldExchange.getIn().setBody(orders);

        // return old as this is the one that has all the orders gathered until now
        return oldExchange;
    }
}</code></pre></div></div><div class="paragraph"><p>So lets run the sample and see how it works.</p></div><div class="paragraph"><p>We send an Exchange to the<strong>direct:start</strong>endpoint containing a IN body with the String value: A@B@C. The flow is:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code>HandleOrder: A
HandleOrder: B
Aggregate old orders: (id=1,item=A)
Aggregate new order: (id=2,item=B)
HandleOrder: C
Aggregate old orders: (id=1,item=A);(id=2,item=B)
Aggregate new order: (id=3,item=C)
BuildCombinedResponse: (id=1,item=A);(id=2,item=B);(id=3,item=C)
Response to caller: Response[(id=1,item=A);(id=2,item=B);(id=3,item=C)]</code></pre></div></div></div><div class="sect2"><h3 id="_stop_processing_in_case_of_exception"><a class="anchor" href="#_stop_processing_in_case_of_exception"></a>Stop processing in case of exception</h3><div class="paragraph"><p>The Splitter will by default continue to process the entire Exchange even in case of one of the splitted message will thrown an exception during routing. For example if you have an Exchange with 1000 rows that you split and route each sub message. During processing of these sub messages an exception is thrown at the 17th. What Camel does by default is to process the remainder 983 messages. You have the chance to remedy or handle this in the<code>AggregationStrategy</code>. But sometimes you just want Camel to stop and let the exception be propagated back, and let the Camel error handler handle it. You can do this in Camel 2.1 by specifying that it should stop in case of an exception occurred. This is done by the<code>stopOnException</code>option as shown below:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:start")
    .split(body().tokenize(",")).stopOnException()
        .process(new MyProcessor())
        .to("mock:split");</code></pre></div></div><div class="paragraph"><p>And using XML DSL you specify it as follows:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
    &lt;from uri="direct:start"/&gt;
    &lt;split stopOnException="true"&gt;
        &lt;tokenize token=","/&gt;
        &lt;process ref="myProcessor"/&gt;
        &lt;to uri="mock:split"/&gt;
    &lt;/split&gt;
&lt;/route&gt;</code></pre></div></div></div><div class="sect2"><h3 id="_using_onprepare_to_execute_custom_logic_when_preparing_messages"><a class="anchor" href="#_using_onprepare_to_execute_custom_logic_when_preparing_messages"></a>Using onPrepare to execute custom logic when preparing messages</h3><div class="paragraph"><p><strong>Available as of Camel 2.8</strong></p></div><div class="paragraph"><p>See details at Multicast EIP</p></div></div><div class="sect2"><h3 id="_sharing_unit_of_work"><a class="anchor" href="#_sharing_unit_of_work"></a>Sharing unit of work</h3><div class="paragraph"><p><strong>Available as of Camel 2.8</strong></p></div><div class="paragraph"><p>The Splitter will by default not share unit of work between the parent exchange and each splitted exchange. This means each sub exchange has its own individual unit of work. For example you may have an use case, where you want to split a big message. And you want to regard that process as an atomic isolated operation that either is a success or failure. In case of a failure you want that big message to be moved into a dead letter queue. To support this use case, you would have to share the unit of work on the Splitter.</p></div><div class="paragraph"><p>Here is an example in Java DSL</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">errorHandler(deadLetterChannel("mock:dead").useOriginalMessage()
        .maximumRedeliveries(3).redeliveryDelay(0));

from("direct:start")
    .to("mock:a")
    // share unit of work in the splitter, which tells Camel to propagate failures from
    // processing the splitted messages back to the result of the splitter, which allows
    // it to act as a combined unit of work
    .split(body().tokenize(",")).shareUnitOfWork()
        .to("mock:b")
        .to("direct:line")
    .end()
    .to("mock:result");

from("direct:line")
    .to("log:line")
    .process(new MyProcessor())
    .to("mock:line");</code></pre></div></div><div class="paragraph"><p>Now in this example what would happen is that in case there is a problem processing each sub message, the error handler will kick in (yes error handling still applies for the sub messages).<strong>But</strong>what doesn&#8217;t happen is that if a sub message fails all redelivery attempts (its exhausted), then its<strong>not</strong>moved into that dead letter queue. The reason is that we have shared the unit of work, so the sub message will report the error on the shared unit of work. When the Splitter is done, it checks the state of the shared unit of work and checks if any errors occurred. And if an error occurred it will set the exception on the Exchange and mark it for rollback. The error handler will yet again kick in, as the Exchange has been marked as rollback and it had an exception as well. No redelivery attempts is performed (as it was marked for rollback) and the Exchange will be moved into the dead letter queue.</p></div><div class="paragraph"><p>Using this from XML DSL is just as easy as you just have to set the<code>shareUnitOfWork</code>attribute to true:</p></div><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext errorHandlerRef="dlc" xmlns="http://camel.apache.org/schema/spring"&gt;

  &lt;!-- define error handler as DLC, with use original message enabled --&gt;
  &lt;errorHandler id="dlc" type="DeadLetterChannel" deadLetterUri="mock:dead" useOriginalMessage="true"&gt;
    &lt;redeliveryPolicy maximumRedeliveries="3" redeliveryDelay="0"/&gt;
  &lt;/errorHandler&gt;

  &lt;route&gt;
    &lt;from uri="direct:start"/&gt;
    &lt;to uri="mock:a"/&gt;
    &lt;!-- share unit of work in the splitter, which tells Camel to propagate failures from
         processing the splitted messages back to the result of the splitter, which allows
         it to act as a combined unit of work --&gt;
    &lt;split shareUnitOfWork="true"&gt;
      &lt;tokenize token=","/&gt;
      &lt;to uri="mock:b"/&gt;
      &lt;to uri="direct:line"/&gt;
    &lt;/split&gt;
    &lt;to uri="mock:result"/&gt;
  &lt;/route&gt;

  &lt;!-- route for processing each splitted line --&gt;
  &lt;route&gt;
    &lt;from uri="direct:line"/&gt;
    &lt;to uri="log:line"/&gt;
    &lt;process ref="myProcessor"/&gt;
    &lt;to uri="mock:line"/&gt;
  &lt;/route&gt;

&lt;/camelContext&gt;</code></pre></div></div><div class="admonitionblock note"><table><tr><td class="icon"><i class="fa icon-note" title="Note"></i></td><td class="content"><div class="title">Implementation of shared unit of work</div><div class="paragraph"><p>So in reality the unit of work is not shared as a single object instance. Instead<code>SubUnitOfWork</code>is attached to their parent, and issues callback to the parent about their status (commit or rollback). This may be refactored in Camel 3.0 where larger API changes can be done.</p></div></td></tr></table></div></div></div></div></article></main></div><footer class="footer"><p>This page was built using the Antora default UI.</p><p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p></footer><script src="../../_/js/site.js"></script><script src="../../_/js/vendor/highlight.js"></script><script>hljs.initHighlighting()</script></body></html>